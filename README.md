# Steak_1
### 1. Постановка задачи
Реализовать класс PersonKeeper  с методами readPersons и writePersons. Метод readPersons должен считывать информацию о людях из входного потока (файла), создавать на основе этой информации объекты класса Person, и помещать их в стек. Формат входного файла должен быть такой: 

    Фамилия Имя Отчество 

В качестве разделителей могут выступать пробелы, табуляции, переводы строки. 
 
 ### 2. Предлагаемое решение
 В качестве основной архитектуры будет использоваться патерн Singlton. Так как нам необходимо что в приложении будет единственный экземпляр класса Steak, предоставляющий глобальную точку доступа к этому экземпляру. Описание паттерна дано в коде с комментариями.
 
 ### 3. Код программы
  Код программы представлен в репозитории
  
  ### 4. Инструкция пользователя
  Чтение из файла идет через 
  
       PersonKeeper& instance = PersonKeeper ::Instance(); 
       instance.readPersons(path);
       
 где, path - путь к файлу с базой данных.
 Формат данных должен соответсвовать   
      
      Фамилия Имя Отчество 
 Запись происходит через 
 
       instance.writePerson(path);
  
### 5. Тестирование
В ходе тестирование были разобраны такие тесты как:

input_1.txt данные представленны в формате заявленом в описании задачи. Программа записывает в output_1.txt данные требуемом формате.

input_2.txt данные представлены в формате заявленом в описании задачи, но со случаным количеством пробелов, табуляций, переносом строки. Программа записывает в output_2.txt данные требуемом формате.

input_3.txt есть пропуски в ФИО. Программа бросит исключение ExceptionData  с предупреждение о том что данные не валидны. 

input_4.txt файл является пустым. Программа бросит исключение ExceptionData с предупреждением о том что файл пуст.

input_5.txt файл -  проверка на отсутствия входного файла. Вызывает исключение ExceptionData с предупреждением о том что не удалось открыть файл.

--------------------------------------------------------------------------------------------------------------------------------------------------------
# Ответы на вопросы

Хаос в комитах связан с тем что я не сразу разобрался как работает Git. Я как-то создал ветку develop отдельно от master и не могу их слить. В следующей лабораторной я учел ошибки и сделал все нормально. Могу пересоздать репозиторий для данной лабораторной, если данное проишествие критично.

Процесс тестирования я описал в пункте 5. 
Ситуация я формировал из всех возможных, по моему мнению, вариатов предоставленных данных. 

![image](https://user-images.githubusercontent.com/64350198/119304729-e1d45180-bc91-11eb-919d-1b6141ee5fed.png)

Тут я переполняю стэк и тестрию поведение программы. Программа вызывает исключение ExceptionStackOverflor которое предупреждает о переполнение стэка. Аналогично с проверкой стека на пустоту.

![image](https://user-images.githubusercontent.com/64350198/119305135-86ef2a00-bc92-11eb-8de5-883a7449a0a1.png)

Функция предоставляющая точку доступа к обьекту класса создающий статический объект.

Статическая переменная сохраняет свое значение даже после выхода из блока, в котором она определена. То есть она создается (и инициализируется) только один раз, а затем сохраняется на протяжении выполнения всей программы.

![image](https://user-images.githubusercontent.com/64350198/119305878-87d48b80-bc93-11eb-9b73-c1add35edd90.png)

*Для работы с исключительными ситуациями. 

![image](https://user-images.githubusercontent.com/64350198/119306174-003b4c80-bc94-11eb-9019-3d864d3be5fa.png)

Под вмешательством в реализацию я имею ввиду изменения содержания приватных данных или обращение к приватным функциям. Все это может вызвать нестандартное поведение программы, что повлечет за собой ее падение. Под определёнными участками кода я имел именно это.

Я имелл ввиду что метод возращает данные костантного типа, что не дает их менять.  ptr обрабатывает value как константу, поэтому изменение значения переменной value через ptr не допускается. 

 Константный метод — это метод, который гарантирует, что не будет изменять объект или вызывать неконстантные методы класса (поскольку они могут изменить объект).
 
 Удобство заключается в том, что я в методе void PersonKeeper ::writePerson(std::string path) могу через него итеравтивно обращаться к данным стека, и записывать их в файл.
 
 ![image](https://user-images.githubusercontent.com/64350198/119310539-12b88480-bc9a-11eb-8eba-bffa6ff8a91f.png)

Да данный код вмешивается в реализацию, удаляет данные как я понял. Но в своей программе подобный код воспроизвести не получилось, так как вмсето

     int *ptr = st. get_ptr()
 
 должно быть 
 
      const int *ptr = st. get_ptr() 
Но тогда все хорошо.
Пример нарушения инкапсуляции 

    class Contact
    {
        private:
            int mobile;           
            int home_number;             
        public:
        Contact()                    
        {
            mobile = 99999;
            home_number = 11111;
        }
        
    };

    struct Contact_struct
    {
    int mobile;
    int home_number;
    };

    int main()
    {
    Contact My;
    Contact_struct * structured_My;

    structured_My = (Contact_struct *) & My;

    structured_Tony->mobile_number = 20;
    structured_Tony->home_number = 30;

    }
Приватные данные были прочитаны и изменены благодаря преобразованию типов.


